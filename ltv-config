#!/usr/bin/python3
# -*- coding: utf-8 -*-
# pylint: disable=C0103,C0301,R0912,R0914,R0915,R1702
#
#######################################################################
#
# Copyright Â© 2018 Jim Lee
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#######################################################################
#
#  ltv-config
#
#  A leetv utility program
#
#  Graphical configuration/schedule editor for leetv
#
#  (alternatively, a simple text editor can be used
#  on ~/.leetv/sched/*.ini and ~/.leetv/config/settings.ini)
#
#  Last update: 2018-06-03
#

import sys
import os
import urllib.parse
from datetime import date, datetime
import time
from configparser import ConfigParser
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox

from leeutils import *


__version__ = '1.00'

class FileList:
    """
    gathers all media lists together for scheduling
    along with min/max/avg video length per series
    """
    directory = ''
    series_list = []

    def __init__(self):
        self.directory = os.path.join(os.getenv('HOME'), '.leetv', 'media')
        for series_file in filewalk(self.directory):
            # collect all the media lists
            if series_file.endswith('.lst'):
                fn, ft = self.get_filelist(series_file)
                min = 99999999
                max = 0
                minname = ''
                maxname = ''
                total = 0
                # for each filename in a single media list
                for i, name in enumerate(fn):
                    # convert ms to minutes
                    runtime = int(ft[i]) / 1000 / 60
                    # calc min/max/avg
                    total += runtime
                    if runtime > max:
                        max = runtime
                        maxname = name
                    if runtime < min:
                        min = runtime
                        minname = name
                s = os.path.basename(series_file)
                minname = urllib.parse.unquote(os.path.basename(minname))
                maxname = urllib.parse.unquote(os.path.basename(maxname))
                self.series_list.append([s.replace('.lst',''), round(total / len(fn), 2), round(min, 2), minname, round(max, 2), maxname])
        self.series_list.sort()
        self.series_list.append(['blank', 0, 0, '', 0, ''])

    def get_filelist(self, filename, shuffle=False):
        f = list()
        t = list()

        if not os.path.isfile(filename):
            print('{} does not exist!'.format(filename))
            sys.exit(1)

        with open(filename, 'r') as fp:
            lst = fp.readlines()
            if shuffle:
                random.shuffle(lst)
            for x in lst:
                a, b = x.split(':')
                f.append(a.strip())
                t.append(b.strip())
            return (f, t)


class MyCombobox(ttk.Combobox):
    '''
    Subclass of ttk.Combobox
    Sets popdown list text color
    '''
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.bind('<Map>', self._change_popdown_color)

    # not sure why I need to do this, but the default values
    # (on my systems) are white text on a white background,
    # rendering the list invisible.
    def _change_popdown_color(self, *args):
        popdown = self.tk.eval('ttk::combobox::PopdownWindow {}'.format(self))
        self.tk.call('{}.f.l'.format(popdown), 'configure', '-foreground', 'black')
        self.tk.call('{}.f.l'.format(popdown), 'configure', '-background', 'white')


def main():

    days=('mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun')

    # tuple of 1/2 hour time slots in a day - 24hr time format
    times = ('0000', '0030', '0100', '0130', '0200', '0230',
             '0300', '0330', '0400', '0430', '0500', '0530',
             '0600', '0630', '0700', '0730', '0800', '0830',
             '0900', '0930', '1000', '1030', '1100', '1130',
             '1200', '1230', '1300', '1330', '1400', '1430',
             '1500', '1530', '1600', '1630', '1700', '1730',
             '1800', '1830', '1900', '1930', '2000', '2030',
             '2100', '2130', '2200', '2230', '2300', '2330')


    def get_schedule(day):
        ''' read schedule for day into comboboxes '''
        sched_file = os.path.join(os.getenv('HOME'), '.leetv', 'sched', day + '.ini')
        sched = ConfigParser()
        sched.read(sched_file)

        for i, slot in enumerate(times):
            combo[i].set(sched.get(slot, 'series', fallback = 'error'))
            seq[i].set(sched.get(slot, 'seq', fallback = 'error'))

    def set_schedule(day):
        ''' save schedule in comboboxes to ini file '''
        sched_file = os.path.join(os.getenv('HOME'), '.leetv', 'sched', day + '.ini')
        # sched_file =  day + '.test'
        sched = ConfigParser()

        for i, slot in enumerate(times):
            sched.add_section(slot)
            sched.set(slot, 'series',combo[i].get())
            sched.set(slot, 'seq',seq[i].get())
            with open(sched_file, 'w') as fp:
                sched.write(fp)

    def get_sc():
        ''' called when radiobutton selected '''
        get_schedule(days[v.get()])
        update_cb()

    def set_sc():
        ''' called when save button clicked '''
        # which radiobutton is selected?
        day = days[v.get()]

        if messagebox.askokcancel('Save Schedule', 'Overwrite {}.ini?'.format(day)):
            set_schedule(day)

    def clear_combos():
        ''' called when clear button clicked '''
        # set all series boxes to last item ('blank')
        # set all seq boxes to 'linear'
        for idx in range(48):
            combo[idx].set(names[-1])
            seq[idx].set(seqs[0])
        update_cb()

    def update_cb():
        '''
        set color of combobox text fields
        based on average episode length:
        '''
        for i in range(48):
            for idx in s.series_list:
                if idx[0] == combo[i].get():
                    if idx[0] == 'blank':
                        # blank series has no length
                        combo[i].configure(foreground='black')
                    elif idx[1] < 30:
                        # series avg is less than 1/2 hour/episode
                        combo[i].configure(foreground='green')
                    elif idx[1] >= 30 and idx[1] < 60:
                        # series avg fits in an hour (2 slots)
                        combo[i].configure(foreground='blue')
                    elif idx[1] >= 60:
                        # series avg is more than an hour
                        combo[i].configure(foreground='red')
                    break


    # get all our media lists to populate the comboboxes with
    s = FileList()

    # picklist for series comboboxes
    names = []
    for i in s.series_list:
        names.append(i[0])

    # picklist for sequence comboboxes
    seqs = ['linear', 'random']
    for i in range(2, 48):
        seqs.append(str(i))

    root = tk.Tk()
    root.title('LeeTV Configuration Editor')
    root.option_add('*TCombobox*Listbox.selectBackground', 'blue')
    root.option_add('*TCombobox*Listbox.selectForeground', 'white')
    root.option_add('*TCombobox*Listbox.Background', 'white')
    root.option_add('*TCombobox*Listbox.Foreground', 'black')

    # ttk styles are buggy.  Order matters and some options are ignored.
    # time to switch to Qt?
    style = ttk.Style()
    # print(style.theme_names())
    style.theme_use('alt')
    style.map('TCombobox', fieldbackground=[('readonly','white')])
    style.map('TCombobox', selectbackground=[('readonly', 'white')])
    # style.map('TCombobox', selectforeground=[('readonly', 'black')])


    buttonframe = ttk.Frame(root, padding='5 5 5 5')
    buttonframe.grid(column=0, row=0, sticky='NSEW')

    dayframe = ttk.LabelFrame(root, text='Select a Day', padding='5 5 5 5')
    dayframe.grid(column=0, row=1, sticky='NSEW')

    comboframe = ttk.Frame(root, padding='5 5 5 5')
    comboframe.grid(column=0, row=2, sticky='NSEW')

    top = dayframe.winfo_toplevel()
    top.rowconfigure(0, weight=1)
    top.rowconfigure(1, weight=1)
    top.rowconfigure(2, weight=1)
    top.columnconfigure(0, weight=1)

    combo = list()
    seq = list()
    combo_label = list()
    combo_var = list()
    seq_var = list()

    # day of the week radiobuttons
    v = tk.IntVar()
    b1 = ttk.Radiobutton(dayframe, text='Mon', variable=v, value=0, command=get_sc)
    b1.grid(column=0, row=0, padx=8, sticky='NSEW')
    b1.rowconfigure(0, weight=1)
    b1.columnconfigure(0, weight=1)
    dayframe.rowconfigure(0, weight=1)
    dayframe.columnconfigure(0, weight=1)

    b2 = ttk.Radiobutton(dayframe, text='Tue', variable=v, value=1, command=get_sc)
    b2.grid(column=1, row=0, padx=8, sticky='NSEW')
    b2.rowconfigure(0, weight=1)
    b2.columnconfigure(1, weight=1)
    dayframe.columnconfigure(1, weight=1)

    b3 = ttk.Radiobutton(dayframe, text='Wed', variable=v, value=2, command=get_sc)
    b3.grid(column=2, row=0, padx=8, sticky='NSEW')
    b3.rowconfigure(0, weight=1)
    b3.columnconfigure(2, weight=1)
    dayframe.columnconfigure(2, weight=1)

    b4 = ttk.Radiobutton(dayframe, text='Thu', variable=v, value=3, command=get_sc)
    b4.grid(column=3, row=0, padx=8, sticky='NSEW')
    b4.rowconfigure(0, weight=1)
    b4.columnconfigure(3, weight=1)
    dayframe.columnconfigure(3, weight=1)

    b5 = ttk.Radiobutton(dayframe, text='Fri', variable=v, value=4, command=get_sc)
    b5.grid(column=4, row=0, padx=8, sticky='NSEW')
    b5.rowconfigure(0, weight=1)
    b5.columnconfigure(4, weight=1)
    dayframe.columnconfigure(4, weight=1)

    b6 = ttk.Radiobutton(dayframe, text='Sat', variable=v, value=5, command=get_sc)
    b6.grid(column=5, row=0, padx=8, sticky='NSEW')
    b6.rowconfigure(0, weight=1)
    b6.columnconfigure(5, weight=1)
    dayframe.columnconfigure(5, weight=1)

    b7 = ttk.Radiobutton(dayframe, text='Sun', variable=v, value=6, command=get_sc)
    b7.grid(column=6, row=0, padx=8, sticky='NSEW')
    b7.rowconfigure(0, weight=1)
    b7.columnconfigure(6, weight=1)
    dayframe.columnconfigure(6, weight=1)

    # clear and save buttons
    b8 = ttk.Button(buttonframe, text='Clear', command=clear_combos)
    b8.grid(column=0, row=0, padx=8, sticky='NSEW')
    b8.rowconfigure(0, weight=1)
    b8.columnconfigure(0, weight=1)
    buttonframe.columnconfigure(0, weight=1)

    b9 = ttk.Button(buttonframe, text='Save', command=set_sc)
    b9.grid(column=1, row=0, padx=8, sticky='NSEW')
    b9.rowconfigure(0, weight=1)
    b9.columnconfigure(1, weight=1)
    buttonframe.columnconfigure(1, weight=1)

    for i in range(48):
        combo_var.append('')
        seq_var.append('')

    # create grid of 96 time slot combo boxes with labels
    # 48 time slot labels
    # 48 series boxes
    # 48 sequence boxes

    # time slot labels
    for col in range(6):
        for row in range(8):
            idx = col * 8 + row
            # convert 24hr to am/pm
            if idx > 23:
                if idx > 25:
                    hr = times[idx - 24][0:2]
                else:
                    hr = times[idx][0:2]
                mn = times[idx][2:] + 'pm'
            else:
                hr = times[idx][0:2]
                mn = times[idx][2:] + 'am'
            txt = '[{}]   {}:{}'.format(times[idx], hr, mn)
            combo_label.append(ttk.Label(comboframe,
                                         text=txt,
                                         anchor='w',
                                         foreground='#3f007f'))
            combo_label[idx].grid(row=row*3, column=col, pady=2, sticky='NSEW')
            combo_label[idx].rowconfigure(row*3, weight=1)
            combo_label[idx].columnconfigure(col, weight=1)
            comboframe.rowconfigure(row*3, weight=1)
            comboframe.columnconfigure(col, weight=1)

    # series boxes
    for col in range(6):
        for row in range(8):
            idx = col * 8 + row
            combo.append(ttk.Combobox(comboframe,
                                    validate='all',
                                    validatecommand=update_cb,
                                    state='readonly',
                                    textvariable=combo_var[idx]))
            combo[idx].grid(row=row*3+1, column=col, padx=8, pady=2, sticky='NSEW')
            combo[idx].rowconfigure(row*3+1, weight=1)
            combo[idx].columnconfigure(col, weight=1)
            comboframe.rowconfigure(row*3+1, weight=1)
            comboframe.columnconfigure(col, weight=1)
            combo[idx]['values'] = names

    # sequence boxes
    for col in range(6):
        for row in range(8):
            idx = col * 8 + row
            seq.append(ttk.Combobox(comboframe,
                                  state='readonly',
                                  textvariable=seq_var[idx]))
            seq[idx].grid(row=row*3+2, column=col, padx=8, pady=2, sticky='NSEW')
            seq[idx].rowconfigure(row*3+2, weight=1)
            seq[idx].columnconfigure(col, weight=1)
            comboframe.rowconfigure(row*3+2, weight=1)
            comboframe.columnconfigure(col, weight=1)
            seq[idx]['values'] = seqs

    # default to Monday schedule
    get_schedule('mon')
    update_cb()

    root.mainloop()

    return 0

if __name__ == '__main__':
    sys.exit(main())
